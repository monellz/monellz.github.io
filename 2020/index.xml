<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2020s on zrx的外置记忆模块</title>
    <link>https://www.monellz.xyz/2020/</link>
    <description>Recent content in 2020s on zrx的外置记忆模块</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 10 Aug 2020 10:46:03 +0800</lastBuildDate>
    
	<atom:link href="https://www.monellz.xyz/2020/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>bash脚本中传递带引号的参数</title>
      <link>https://www.monellz.xyz/2020/08/10/bash_pass_args/</link>
      <pubDate>Mon, 10 Aug 2020 10:46:03 +0800</pubDate>
      
      <guid>https://www.monellz.xyz/2020/08/10/bash_pass_args/</guid>
      <description>用bash来执行其他文件时，若直接使用$*来传递参数，则会导致其中的双引号被去掉，应使用&amp;quot;$@&amp;quot;来传递参数</description>
    </item>
    
    <item>
      <title>Linux kernel入口</title>
      <link>https://www.monellz.xyz/2020/02/20/linux_kernel_entry/</link>
      <pubDate>Thu, 20 Feb 2020 00:54:03 +0800</pubDate>
      
      <guid>https://www.monellz.xyz/2020/02/20/linux_kernel_entry/</guid>
      <description>入口为init/main.c中的start_kernel函数
经过一系列的初始化，最后调用rest_init()，在这个函数里，最终调用cpu_startup_entry(位于kernel/sched/idle.c)，通过cpu_idle_loop()进入idle线程的循环
从kern.log来看，一开始只有cpu0是启动的，在第一次进入idle之后，开始一个个enable其他的cpu
而module的加载还在后面
多CPU启动 boot_cpu_init(); setup_nr_cpu_ids(); setup_per_cpu_areas(); boot_cpu_state_init(); smp_prepare_boot_cpu(); boot_cpu_init 在start_kernel中调用boot_cpu_init()位于kernel/cpu.c，用于activate the first processor
smp_processor_id()被定义在include/linux/smp.h
#ifdef CONFIG_DEBUG_PREEMPT extern unsigned int debug_smp_processor_id(void); #define smp_processor_id() debug_smp_processor_id()#else#define smp_processor_id() raw_smp_processor_id()#endif在hikey970中没有设置CONFIG_DEBUG_PREEMPT因此为raw_smp_processor_id()
//arch/arm64/include/asm/smp.h #define raw_smp_processor_id() (current_thread_info()-&amp;gt;cpu) static inline struct thread_info *current_thread_info(void) { unsigned long sp_el0; asm (&amp;#34;mrs %0, sp_el0&amp;#34; : &amp;#34;=r&amp;#34; (sp_el0)); return (struct thread_info *)sp_el0; } //arch/arm64/include/asm/thread_info.h struct thread_info { unsigned long	flags;	/* low level flags */ mm_segment_t	addr_limit;	/* address limit */ struct task_struct	*task;	/* main task structure */ #ifdef CONFIG_ARM64_SW_TTBR0_PAN	u64	ttbr0;	/* saved TTBR0_EL1 */ #endif	int	preempt_count;	/* 0 =&amp;gt; preemptable, &amp;lt;0 =&amp;gt; bug */ int	cpu;	/* cpu */ }; setup_nr_cpu_ids /* An arch may set nr_cpu_ids earlier if needed, so this would be redundant */ void __init setup_nr_cpu_ids(void) { nr_cpu_ids = find_last_bit(cpumask_bits(cpu_possible_mask),NR_CPUS) + 1; } setup_per_cpu_areas //arch/arm64/mm/numa.</description>
    </item>
    
    <item>
      <title>hikey970开发板环境配置与PMU读取</title>
      <link>https://www.monellz.xyz/2020/02/18/board/</link>
      <pubDate>Tue, 18 Feb 2020 21:53:34 +0800</pubDate>
      
      <guid>https://www.monellz.xyz/2020/02/18/board/</guid>
      <description>开发板参数 hikey970开发板参数如下
其对应的kernel源码在这里
PMU读取 烧写的系统为lebian9
由于架构为armv8，github上有个很好的用作参考的库,enable_arm_pmu
  解决编译问题
enable_arm_pmu需要先往内核插入一个模块，因此需要相应架构头文件等进行模块的编译
板子上的uname -r会有奇怪的版本号出现，无法通过包管理器等进行头文件等的安装以及库里Makefile的使用
因此直接利用源码(下面被放在了linux-headers-hikey970-v4.9.zip里)，在对应位置手动进行目录的构建
#!/bin/bash #run by root mkdir -p /lib/modules/`uname -r` mv /home/shunya/linux-headers-hikey970-v4.9.zip /usr/src/ cd /usr/src unzip linux-headers-hikey970-v4.9.zip rm linux-headers-hikey970-v4.9.zip cd linux-headers-hikey970-v4.9 apt-get install bc gunzip &amp;lt; /proc/config.gz &amp;gt; .config make oldconfig make prepare make scripts cd /lib/modules/`uname -r` ln -s /usr/src/linux-headers-hikey970-v4.9 build   kernel源码dts中添加pmu(支持perf_event)
在arch/arm64/boot/dts/hisilicon/kirin970-hikey970.dts中添加如下
pmu { compatible = &amp;#34;arm,armv8-pmuv3&amp;#34;; interrupts = &amp;lt;0 24 4&amp;gt;, &amp;lt;0 25 4&amp;gt;, &amp;lt;0 26 4&amp;gt;, &amp;lt;0 27 4&amp;gt;, &amp;lt;0 2 4&amp;gt;, &amp;lt;0 3 4&amp;gt;, &amp;lt;0 4 4&amp;gt;, &amp;lt;0 5 4&amp;gt;; interrupt-affinity = &amp;lt;&amp;amp;cpu0&amp;gt;, &amp;lt;&amp;amp;cpu1&amp;gt;, &amp;lt;&amp;amp;cpu2&amp;gt;, &amp;lt;&amp;amp;cpu3&amp;gt;, &amp;lt;&amp;amp;cpu4&amp;gt;, &amp;lt;&amp;amp;cpu5&amp;gt;, &amp;lt;&amp;amp;cpu6&amp;gt;, &amp;lt;&amp;amp;cpu7&amp;gt;; };   测试 实际测试中发现在单核(其他cpu被disable)情况下pmu(寄存器)读取十分稳定，但在多核情况仍然会出现illegal instruction的问题</description>
    </item>
    
  </channel>
</rss>