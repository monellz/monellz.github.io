<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sc19 on zrx的外置记忆模块</title><link>https://www.monellz.xyz/tags/sc19/</link><description>Recent content in sc19 on zrx的外置记忆模块</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 23 Nov 2020 12:10:37 +0800</lastBuildDate><atom:link href="https://www.monellz.xyz/tags/sc19/index.xml" rel="self" type="application/rss+xml"/><item><title>DaCe(SC19)分析-2 DaceProgram初始化</title><link>https://www.monellz.xyz/2020/11/23/dace-2/</link><pubDate>Mon, 23 Nov 2020 12:10:37 +0800</pubDate><guid>https://www.monellz.xyz/2020/11/23/dace-2/</guid><description>上次说到，dace采用装饰器来修饰需要被优化的函数，最终会返回一个parser.DaceProgram(f, args, kwargs)，其中f是被修饰函数的指针，args是可选的装饰器参数，指定函数的参数类型
DaceProgram被定义在了dace/frontend/python/parser.py里，其初始化函数如下
class DaceProgram: &amp;#34;&amp;#34;&amp;#34; A data-centric program object, obtained by decorating a function with `@dace.</description></item><item><title>DaCe(SC19)分析-3 编译和生成</title><link>https://www.monellz.xyz/2020/11/24/dace-3/</link><pubDate>Mon, 23 Nov 2020 12:10:37 +0800</pubDate><guid>https://www.monellz.xyz/2020/11/24/dace-3/</guid><description>继续之前的DaceProgram
DaceProgram重写了自己的__call__，因此被dace装饰的函数，将会在被调用时进行编译和运行
def __call__(self, *args, **kwargs): &amp;#34;&amp;#34;&amp;#34; Convenience function that parses, compiles, and runs a DaCe program.</description></item><item><title>DaCe(SC19)分析-1 入口</title><link>https://www.monellz.xyz/2020/11/19/dace-1/</link><pubDate>Thu, 19 Nov 2020 10:09:38 +0800</pubDate><guid>https://www.monellz.xyz/2020/11/19/dace-1/</guid><description>开一个新坑，对SC19的异构编程框架文章dace分析源码，顺便看一下现代python的写法以及与后端c++的协同方式
从dace的tutorial例子出发
import dace @dace.program def getstarted(A): return A + A 啪就来个装饰器，很快啊（
首先在dace/__init__.py下，所有装饰被导出
from .frontend.python.decorators import * 继续往里走就是dace/frontend/python/decorators.</description></item></channel></rss>