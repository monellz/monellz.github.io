<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>os on zrx的外置记忆模块</title>
    <link>https://www.monellz.xyz/categories/os/</link>
    <description>Recent content in os on zrx的外置记忆模块</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 20 Feb 2020 00:54:03 +0800</lastBuildDate>
    
	<atom:link href="https://www.monellz.xyz/categories/os/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linux kernel入口</title>
      <link>https://www.monellz.xyz/2020/02/20/linux_kernel_entry/</link>
      <pubDate>Thu, 20 Feb 2020 00:54:03 +0800</pubDate>
      
      <guid>https://www.monellz.xyz/2020/02/20/linux_kernel_entry/</guid>
      <description>入口为init/main.c中的start_kernel函数
经过一系列的初始化，最后调用rest_init()，在这个函数里，最终调用cpu_startup_entry(位于kernel/sched/idle.c)，通过cpu_idle_loop()进入idle线程的循环
从kern.log来看，一开始只有cpu0是启动的，在第一次进入idle之后，开始一个个enable其他的cpu
而module的加载还在后面
多CPU启动 boot_cpu_init(); setup_nr_cpu_ids(); setup_per_cpu_areas(); boot_cpu_state_init(); smp_prepare_boot_cpu(); boot_cpu_init 在start_kernel中调用boot_cpu_init()位于kernel/cpu.c，用于activate the first processor
smp_processor_id()被定义在include/linux/smp.h
#ifdef CONFIG_DEBUG_PREEMPT extern unsigned int debug_smp_processor_id(void); #define smp_processor_id() debug_smp_processor_id()#else#define smp_processor_id() raw_smp_processor_id()#endif在hikey970中没有设置CONFIG_DEBUG_PREEMPT因此为raw_smp_processor_id()
//arch/arm64/include/asm/smp.h #define raw_smp_processor_id() (current_thread_info()-&amp;gt;cpu) static inline struct thread_info *current_thread_info(void) { unsigned long sp_el0; asm (&amp;#34;mrs %0, sp_el0&amp;#34; : &amp;#34;=r&amp;#34; (sp_el0)); return (struct thread_info *)sp_el0; } //arch/arm64/include/asm/thread_info.h struct thread_info { unsigned long	flags;	/* low level flags */ mm_segment_t	addr_limit;	/* address limit */ struct task_struct	*task;	/* main task structure */ #ifdef CONFIG_ARM64_SW_TTBR0_PAN	u64	ttbr0;	/* saved TTBR0_EL1 */ #endif	int	preempt_count;	/* 0 =&amp;gt; preemptable, &amp;lt;0 =&amp;gt; bug */ int	cpu;	/* cpu */ }; setup_nr_cpu_ids /* An arch may set nr_cpu_ids earlier if needed, so this would be redundant */ void __init setup_nr_cpu_ids(void) { nr_cpu_ids = find_last_bit(cpumask_bits(cpu_possible_mask),NR_CPUS) + 1; } setup_per_cpu_areas //arch/arm64/mm/numa.</description>
    </item>
    
  </channel>
</rss>